{
  "topic": "操作系统-PV操作与前趋图",
  "core_concept": "核心考点提炼\n\n1.  **信号量 (Semaphore) 与PV操作**：信号量是一个整型变量，用于控制对共享资源的访问。\n    *   **P操作 (Wait/Proberen)**：`P(S)` 表示申请一个资源。如果 `S > 0`，则 `S = S - 1`，进程继续执行；否则，进程阻塞并进入等待队列。\n    *   **V操作 (Signal/Verhogen)**：`V(S)` 表示释放一个资源。`S = S + 1`。如果等待队列中有进程，则唤醒一个进程。\n    *   PV操作必须是原子操作，不可被中断。\n\n2.  **前趋图 (Precedence Graph)**：一个有向无环图 (DAG)，用于表示并发进程之间执行的先后顺序和依赖关系。\n    *   图中的节点代表一个任务或进程，有向边 `(A, B)` 表示任务 A 必须在任务 B 开始之前完成。\n    *   用于分析任务的并行性、关键路径和调度策略。\n\n3.  **互斥与同步**：\n    *   **互斥 (Mutual Exclusion)**：确保在任何时刻，只有一个进程可以进入临界区访问共享资源。通常使用一个初始值为1的二元信号量实现。\n    *   **同步 (Synchronization)**：协调多个进程的执行顺序，以满足特定条件或依赖关系。通常使用计数信号量实现。",
  "knowledge_explanation": "深度精讲\n\n**1. PV操作原理详解**\n\nPV操作是Dijkstra提出的用于进程间通信与同步的机制，基于信号量实现。信号量本质上是一个保护共享资源的计数器。\n\n*   **互斥**：对于临界区问题，设置一个互斥信号量`mutex`，初始值为1。当进程需要进入临界区时，执行`P(mutex)`；当进程离开临界区时，执行`V(mutex)`。这样可以确保每次只有一个进程能成功执行P操作进入临界区，其他进程将被阻塞。\n    \n    Process_i:\n        ...\n        P(mutex);       // 申请进入临界区\n        // 临界区代码 (访问共享资源)\n        V(mutex);       // 释放临界区\n        ...\n    \n\n*   **同步**：例如，生产者-消费者问题。生产者产生数据放入缓冲区，消费者从缓冲区取出数据。需要同步机制确保消费者不会在缓冲区为空时取数据，生产者不会在缓冲区满时放数据。\n    *   `empty`：表示缓冲区空槽的数量，初始值等于缓冲区大小N。\n    *   `full`：表示缓冲区满槽的数量（已有数据项），初始值等于0。\n    *   `mutex`：互斥信号量，用于保护对缓冲区的访问，初始值为1。\n\n    \n    Producer:\n        ...\n        P(empty);       // 检查是否有空位\n        P(mutex);       // 申请访问缓冲区\n        // 生产数据并放入缓冲区\n        V(mutex);       // 释放缓冲区\n        V(full);        // 增加已满槽计数\n        ...\n\n    Consumer:\n        ...\n        P(full);        // 检查是否有数据\n        P(mutex);       // 申请访问缓冲区\n        // 从缓冲区取出数据\n        V(mutex);       // 释放缓冲区\n        V(empty);       // 增加空槽计数\n        ...\n    \n\n**记忆口诀**：\n*   **P**：**P**roberen (荷兰语：尝试/测试) -> **P**repare (准备占用) -> **P**ass (通过) -> 减少信号量 (资源减一)。\n*   **V**：**V**erhogen (荷兰语：增加) -> **V**acant (空闲) -> **V**ictory (完成释放) -> 增加信号量 (资源加一)。\n*   **P在前，V在后**：在进入临界区或使用资源前P，离开临界区或释放资源后V。\n\n**2. 前趋图原理详解**\n\n前趋图是一种图形化表示，清晰地展示了任务间的并行和串行关系。节点通常表示一个进程或一个操作，有向边表示依赖关系。例如，如果 `A -> B`，则 A 完成后 B 才能开始。\n\n**应用**：\n*   **并行性分析**：没有直接路径相连的节点可能可以并行执行。\n*   **调度优化**：基于前趋图，可以设计出高效的调度策略，最大化并行度，缩短总执行时间。\n*   **系统建模**：复杂系统中的任务流程、数据流和控制流的清晰表达。\n\n**3. 常见问题与易错点**\n*   **死锁 (Deadlock)**：PV操作使用不当可能导致死锁。例如，如果两个进程都尝试获取两个互斥信号量，但获取顺序相反，则可能发生死锁。\n*   **饥饿 (Starvation)**：某些进程可能长时间无法获取所需资源，不断被其他进程抢占。\n*   **信号量初值设定**：根据资源数量和同步需求准确设置信号量的初始值至关重要。\n\n**对比表格：互斥信号量 vs. 计数信号量**\n\n| 特性         | 互斥信号量 (Binary Semaphore)   | 计数信号量 (Counting Semaphore) |\n| :----------- | :---------------------------- | :-------------------------- |\n| **初始值**   | 1 (通常)                        | 任意非负整数 (N)            |\n| **用途**     | 确保临界区互斥访问            | 控制对N个相同资源的访问     |\n| **操作结果** | 只能锁定/解锁临界区           | 允许N个进程同时访问资源     |\n| **典型场景** | 临界区互斥、读者-写者问题等   | 生产者-消费者问题、资源池   |",
  "essay_guide": "论文与案例指导\n\n在软考系统架构设计师的论文和案例分析中，**操作系统-PV操作与前趋图**是一个重要的考点，尤其是在涉及高并发、分布式系统、实时系统以及资源调度的设计与优化时。以下是指导建议：\n\n1.  **论文写作指导**：\n    *   **选题方向**：可以结合实际项目经验，选择“基于PV操作的XXXX系统并发控制设计”、“使用前趋图优化XXXX系统任务调度策略”、“分布式事务中的资源同步机制设计与实现”等主题。\n    *   **结构与内容**：\n        *   **摘要**：概述论文内容、关键问题及解决方案。\n        *   **引言**：背景、问题定义、研究意义，简述PV操作和前趋图的重要性。\n        *   **相关理论**：深入阐述PV操作、信号量、互斥、同步、死锁预防、前趋图等概念。可提及经典问题如生产者-消费者、读者-写者、哲学家就餐问题。\n        *   **系统设计/解决方案**：\n            *   **PV操作应用**：详细描述如何在系统设计中运用PV操作实现进程间互斥与同步。例如，在共享数据访问、消息队列、缓冲区管理、设备驱动等场景中的具体信号量定义、初值设定及P/V操作逻辑。\n            *   **前趋图应用**：解释如何通过前趋图分析系统中的任务依赖关系，识别并行任务，并基于此设计任务调度算法或流程编排。可以绘制简化前趋图作为示例。\n        *   **关键技术与挑战**：探讨如何避免死锁、饥饿，如何处理PV操作的原子性与性能开销，以及在高并发场景下的扩展性问题。\n        *   **系统实现与效果**：简述实现方法、部署环境及效果评估（如性能提升、并发度改善、资源利用率等）。\n        *   **总结与展望**：总结工作，提出未来改进方向。\n    *   **写作技巧**：\n        *   **结合实际**：理论与实践相结合，强调在实际项目中的应用和优化效果。\n        *   **图文并茂**：使用流程图、UML图、前趋图、代码片段等辅助说明。\n        *   **术语规范**：准确使用专业术语，避免口语化表达。\n\n2.  **案例分析指导**：\n    *   **问题识别**：案例中常会描述一个多进程/多线程并发访问共享资源或存在任务依赖关系的场景。首先要识别出：\n        *   哪些是共享资源？\n        *   哪些操作是临界区操作？\n        *   哪些进程之间存在执行顺序的依赖关系？\n        *   是否存在潜在的并发问题（如数据不一致、死锁、饥饿）？\n    *   **方案设计**：\n        *   **定义信号量**：根据识别出的共享资源和同步需求，定义所需的互斥信号量和计数信号量，并给出合理的初始值。\n        *   **应用PV操作**：为每个相关进程或线程的关键代码段（如进入临界区、访问缓冲区、等待事件等）设计P和V操作的调用位置。\n        *   **绘制前趋图**：如果案例涉及任务调度或流程依赖，绘制前趋图清晰表示任务间的先后关系，并分析可能的并行执行路径。可进一步指出如何优化调度。\n        *   **死锁分析与避免**：评估所设计的PV操作是否存在死锁风险，并提出相应的避免策略（如资源有序分配、银行家算法思想等）。\n    *   **效果评估**：分析所提出方案对并发问题（互斥、同步）的解决效果，以及对系统性能、可靠性、可维护性等方面的影响。\n    *   **关键点**：\n        *   **逻辑严谨**：PV操作的位置和信号量初值的设定必须逻辑严谨，确保不会出现死锁、饥饿或功能错误。\n        *   **考虑全面**：除了解决当前问题，还要考虑并发方案的扩展性、性能开销和易维护性。\n        *   **清晰表达**：使用清晰的语言、代码片段、伪代码、图表来阐述设计思路和方案。\n\n**案例分析示例思路**：\n\n假设一个在线票务系统，有多个用户同时购买少量剩余的机票。你需要设计一个并发控制机制。\n\n1.  **识别问题**：机票库存是共享资源，购买操作是临界区操作。多个用户并发购买会导致超卖（数据不一致）。\n2.  **方案设计**：\n    *   定义一个互斥信号量 `ticket_mutex`，初始值为1，用于保护机票库存的读写。\n    *   用户购买流程：\n        `P(ticket_mutex)`\n        `检查库存并扣减`\n        `生成订单`\n        `V(ticket_mutex)`\n    *   如果涉及到库存不足的同步，可能还需要一个计数信号量或者更复杂的机制来等待库存补充。\n3.  **效果评估**：通过`ticket_mutex`确保了同一时刻只有一个用户能够操作库存，避免了超卖问题。但需要注意性能瓶颈，因为所有购买请求都串行化了。",
  "questions": [
    {
      "question": "在一个经典的生产者-消费者问题中，假设缓冲区大小为N，使用信号量进行同步。以下关于信号量初始值的设置，哪一项是正确的？ [2018]",
      "options": [
        "A. 互斥信号量 `mutex` = 0，空槽信号量 `empty` = N，满槽信号量 `full` = 0",
        "B. 互斥信号量 `mutex` = 1，空槽信号量 `empty` = 0，满槽信号量 `full` = N",
        "C. 互斥信号量 `mutex` = 1，空槽信号量 `empty` = N，满槽信号量 `full` = 0",
        "D. 互斥信号量 `mutex` = 0，空槽信号量 `empty` = 0，满槽信号量 `full` = 0"
      ],
      "answer": "C",
      "analysis": "生产者-消费者问题中：\n1. `mutex` 信号量用于互斥访问缓冲区，初始值应为1，表示缓冲区一开始是空闲可访问的。\n2. `empty` 信号量表示缓冲区中空槽的数量，初始值应等于缓冲区总大小 N，因为开始时所有槽都是空的。\n3. `full` 信号量表示缓冲区中已填充数据项的数量，初始值应为0，因为开始时缓冲区没有数据。\n因此，选项 C 是正确的设置。"
    },
    {
      "question": "某系统中有三个并发进程P1、P2、P3，它们访问两个共享资源R1、R2。P1需要R1和R2，P2需要R1，P3需要R2。为防止死锁，信号量S1和S2分别对应R1和R2，初始值都为1。以下哪种P、V操作序列最可能导致死锁？ [2019]",
      "options": [
        "A. P1: P(S1), P(S2); P2: P(S1); P3: P(S2)",
        "B. P1: P(S1), P(S2); P2: P(S1); P3: P(S2) (执行顺序可变)",
        "C. P1: P(S1), P(S2); P2: P(S1); P3: P(S2) (所有V操作在最后)",
        "D. P1: P(S1); P3: P(S2); P1: P(S2); P2: P(S1)"
      ],
      "answer": "D",
      "analysis": "死锁的四个必要条件：互斥、占有并等待、不可剥夺、循环等待。\n选项D中，如果P1先执行P(S1)获取S1，P3先执行P(S2)获取S2。此时P1占有S1等待S2，P3占有S2。如果P1继续执行P(S2)将被阻塞，P3继续执行P(S2)无资源释放。如果P2也执行P(S1)将阻塞。关键在于P1获取S1后，再获取S2，而P3获取S2后，如果P1在等待S2，P3在等待S1，则形成循环等待。\n考虑以下执行顺序：\n1. P1执行P(S1)成功 (S1=0)\n2. P3执行P(S2)成功 (S2=0)\n3. P1尝试执行P(S2)，因S2=0而阻塞，等待S2。\n4. P3尝试执行P(S1)，因S1=0而阻塞，等待S1。\n此时P1和P3互相等待对方持有的资源，形成死锁。\n其他选项中的P操作序列，由于缺乏明确的交错执行顺序，或只有一个进程需要两个资源，不容易形成循环等待。"
    },
    {
      "question": "下列关于PV操作的说法，错误的是哪一项？ [2017]",
      "options": [
        "A. P操作和V操作都必须是原子操作。",
        "B. 信号量只能取非负整数值。",
        "C. PV操作可以用于实现进程间的互斥和同步。",
        "D. 当信号量S的值小于0时，执行V(S)操作会立即唤醒一个等待进程。"
      ],
      "answer": "D",
      "analysis": "A. P操作和V操作是原子操作，这是保证其正确性的基础，否则可能出现竞态条件。正确。\nB. 信号量的典型定义是整型变量，但其值通常用于表示可用资源数，因此一般取非负整数。特殊情况下，负值表示等待进程数，但其语义仍基于资源计数。正确。\nC. PV操作是操作系统中实现进程互斥和同步的经典方法。正确。\nD. 当信号量S的值小于0时，表示有进程在等待。执行V(S)操作时，S的值会先加1。如果加1后S仍小于等于0，那么表明S之前是负值（有等待进程），此时才会唤醒一个等待进程。如果加1后S大于0，说明之前S是-1，加1后变为0，或者更小的负值，但表示还有其他进程在等待，需要根据具体信号量实现机制来确定是否唤醒。但“立即唤醒”的说法并不准确，更重要的是S的值从负数变为0或更小的负数（表示等待进程减少）。通常情况下，如果S从负值加1后仍是负值，则不会唤醒，因为资源仍然不足。只有S从负值加1后变为0或正数，表示有资源可用时才会唤醒。这里说“立即唤醒”不严谨，尤其是在S从负数加1后仍为负数的情况下。标准定义是：`V(S)`操作会使S加1，如果S的值小于或等于0，则唤醒一个阻塞进程。所以，当S<0时，V(S)后S+1，此时S可能仍然小于0，在这种情况下不会唤醒进程。只有当S+1后变为0或正数时，才唤醒等待进程。此选项描述不准确，因此是错误的。"
    },
    {
      "question": "一个具有10个缓冲区的共享缓冲池，采用生产者-消费者模式。当前有3个生产者进程和2个消费者进程。如果初始状态下所有缓冲区都是空的，那么用于控制空闲缓冲区数量的信号量 `empty` 的初始值和用于控制已占用缓冲区数量的信号量 `full` 的初始值分别为多少？ [2021]",
      "options": [
        "A. `empty` = 10, `full` = 0",
        "B. `empty` = 0, `full` = 10",
        "C. `empty` = 1, `full` = 0",
        "D. `empty` = 10, `full` = 10"
      ],
      "answer": "A",
      "analysis": "本题考察生产者-消费者问题中信号量的初始值设定。\n`empty` 信号量表示缓冲区中空闲槽的数量。由于初始状态下所有10个缓冲区都是空的，所以空闲槽的数量为10。\n`full` 信号量表示缓冲区中已占用槽（即已放入数据）的数量。由于初始状态下所有缓冲区都是空的，所以已占用槽的数量为0。\n因此，`empty` 初始值为10，`full` 初始值为0。互斥信号量（如果需要）通常初始值为1，但本题只问`empty`和`full`。"
    },
    {
      "question": "某系统有三个进程 P1、P2、P3，其前趋图如下图所示（图略，假设P1完成后P2和P3可并行执行，P2和P3都完成后P4可执行）。下列哪种说法是错误的？ [2023, 模拟题]",
      "options": [
        "A. P1是所有进程的起始点。",
        "B. P2和P3可以并行执行。",
        "C. P4必须等待P1完成后才能执行。",
        "D. P4的执行不依赖于P2和P3。"
      ],
      "answer": "D",
      "analysis": "根据前趋图的定义和题目描述：\n1. “P1完成后P2和P3可并行执行”：这表示P1是P2和P3的前趋，P2和P3在P1完成后可以同时开始。P1是起始点，A正确。\n2. “P2和P3都完成后P4可执行”：这表示P2和P3都是P4的前趋，P4必须等待P2和P3都完成后才能开始。因此，P4的执行依赖于P2和P3。D选项说“P4的执行不依赖于P2和P3”是错误的。\n3. “P2和P3可以并行执行”：这是题目明确给出的信息，B正确。\n4. “P4必须等待P1完成后才能执行”：因为P4依赖于P2和P3，而P2和P3依赖于P1，所以P4间接依赖于P1，必须等待P1完成后才能执行。C正确。\n因此，错误的说法是D。"
    },
    {
      "question": "考虑一个打印机服务系统，多个进程共享一台打印机。为了确保打印任务的互斥访问，应该如何设置信号量？ [2016]",
      "options": [
        "A. 定义一个计数信号量S，初始值为可同时打印的任务数，进程每次打印前执行P(S)，打印完成后执行V(S)。",
        "B. 定义一个二元信号量S，初始值为1，进程每次打印前执行P(S)，打印完成后执行V(S)。",
        "C. 定义一个二元信号量S，初始值为0，进程每次打印前执行P(S)，打印完成后执行V(S)。",
        "D. 定义一个计数信号量S，初始值为0，进程每次打印前执行P(S)，打印完成后执行V(S)。"
      ],
      "answer": "B",
      "analysis": "本题要求确保打印任务的“互斥访问”，即同一时间只有一个进程能够使用打印机。实现互斥访问最常用的方法是使用一个二元信号量（或互斥锁），其初始值为1。\n*   A选项：计数信号量用于控制对N个相同资源的访问，但这里是一台打印机（唯一资源），且要求互斥，所以不适合。\n*   B选项：定义一个二元信号量S，初始值为1，正好满足互斥访问的需求。进程在打印前执行P(S)申请打印机，打印完成后执行V(S)释放打印机。这是标准的互斥实现方式。\n*   C选项：二元信号量S初始值为0意味着打印机一开始是不可用的，所有进程都会阻塞。只有在某个进程执行V(S)后才能有进程进入，这不符合初始可用的状态。\n*   D选项：计数信号量初始值为0同样不符合需求，且计数信号量本身不用于严格的互斥访问单个资源。\n所以B是正确答案。"
    },
    {
      "question": "在一个经典的读者-写者问题中（写者优先），为了实现写者优先的访问控制，通常需要引入多个信号量。假设`wmutex`用于写者互斥，`rmutex`用于读者互斥，`mutex`用于保护对`readcount`的修改。还需要一个信号量用于实现写者优先，防止读者饥饿。这个信号量的正确设置应该是： [2024, 模拟题]",
      "options": [
        "A. `resource` 初始值 1，保护对实际资源的访问。",
        "B. `readblock` 初始值 1，当有写者等待时阻塞读者。",
        "C. `writeblock` 初始值 0，当有读者时阻塞写者。",
        "D. `readcount` 初始值 0，用于记录读者数量。"
      ],
      "answer": "B",
      "analysis": "读者-写者问题（写者优先）需要解决的核心是：当有写者在等待时，阻止新的读者进入，直到写者完成。这就需要一个信号量来“阻塞”读者。\n*   `wmutex`：保护写者互斥进入写区。通常初始值1。\n*   `rmutex`：保护对`readcount`的互斥访问。通常初始值1。\n*   `resource`：保护对共享资源的读写操作。当有写者时，此信号量为0，阻止读者和写者访问。当没有写者时，允许读者访问。通常初始值1。\n*   为了实现写者优先，需要一个额外的信号量，当有写者尝试进入写区时，它会阻止新的读者进入。这个信号量通常命名为`readblock`（或类似名称），初始值为1。当第一个写者尝试进入时，它会P(`readblock`)，如果此时有读者，读者将无法再进入。当写者完成时，V(`readblock`)释放读者。所以，`readblock` 的作用是，当有写者排队时，新来的读者不能再进入，让当前读者都退出后，写者才能开始。\n*   选项A `resource` 初始值1是保护实际资源的，这是所有读写者问题都有的，但不是专门为写者优先设计的阻塞读者。\n*   选项B `readblock` 初始值1，当有写者等待时，它会被P操作，从而阻止后续读者进入。这是写者优先的关键。\n*   选项C `writeblock` 初始值0，是写者阻塞读者，但初始值0是不对的，应该是允许读者的。且通常是写者阻塞读者的机制，不是写者阻塞自己。\n*   选项D `readcount` 记录读者数量，是一个整型变量，不是信号量。\n因此，B是正确选项。"
    },
    {
      "question": "假设进程P1、P2、P3、P4，其执行顺序由以下前趋图（图中节点为进程，边表示前趋关系）决定：P1 -> P2, P1 -> P3, P2 -> P4, P3 -> P4。若每个进程执行时间均为1个单位，不考虑调度开销，理论上完成所有进程的最短时间为多少个单位？ [2020]",
      "options": [
        "A. 3",
        "B. 4",
        "C. 2",
        "D. 5"
      ],
      "answer": "A",
      "analysis": "根据前趋图 P1 -> P2, P1 -> P3, P2 -> P4, P3 -> P4：\n1. P1先执行，耗时1单位。\n2. P1完成后，P2和P3可以并行执行。它们都耗时1单位。所以P2和P3同时开始，同时结束，这段并行执行的时间为1单位。\n3. P2和P3都完成后，P4才能开始执行。P4耗时1单位。\n总时间 = P1执行时间 + (P2/P3并行执行时间) + P4执行时间\n总时间 = 1 + 1 + 1 = 3个单位。\n因此，最短完成时间为3个单位。"
    },
    {
      "question": "在基于PV操作实现进程同步时，若信号量S的当前值为-2，这意味着什么？ [2022]",
      "options": [
        "A. 有两个进程正在等待资源S。",
        "B. 资源S还有两个可用单元。",
        "C. 信号量S的定义有误。",
        "D. 资源S已耗尽，并且至少有一个进程正在执行V(S)操作。"
      ],
      "answer": "A",
      "analysis": "当信号量S的值为正数时，表示有S个资源可用。\n当信号量S的值为0时，表示没有资源可用。\n当信号量S的值为负数时，其绝对值表示有多少个进程正在等待该资源。\n所以，如果S的当前值为-2，表示有两个进程因P(S)操作失败而被阻塞，正在等待资源S。因此A是正确答案。"
    },
    {
      "question": "在以下哪个应用场景中，通常会使用计数信号量而不是二元信号量？ [2015]",
      "options": [
        "A. 保护一段临界区代码，确保同一时间只有一个线程访问。",
        "B. 实现对只有一个可用设备的独占访问。",
        "C. 管理一个固定大小的缓冲区，生产者放入数据，消费者取出数据。",
        "D. 确保两个线程按照严格的先后顺序执行。"
      ],
      "answer": "C",
      "analysis": "1. **二元信号量 (Binary Semaphore)**：\n    *   初始值通常为1，只能取0或1。\n    *   主要用于实现互斥访问（如临界区），确保一次只有一个进程/线程进入特定代码段。\n    *   A和B都是典型的互斥场景，适合使用二元信号量。\n2. **计数信号量 (Counting Semaphore)**：\n    *   初始值可以为任意非负整数N。\n    *   用于控制对N个相同类型资源的访问。当S的值为正数时，表示有S个资源可用；当S为负数时，其绝对值表示等待资源的进程数。\n    *   C选项描述的是生产者-消费者问题，其中缓冲区有固定大小，需要管理空槽和满槽的数量。这需要用到计数信号量（`empty` 和 `full`）。`empty`初始为缓冲区大小N，`full`初始为0。\n    *   D选项描述的是简单的进程同步，一个进程完成后通知另一个进程开始。这通常可以用一个初始值为0的二元信号量（或者更简单的事件标志）实现，当第一个进程完成时V(S)，第二个进程P(S)。虽然计数信号量也能做，但二元信号量更直接、更简洁。\n因此，C是计数信号量最典型的应用场景。"
    },
    {
      "question": "考虑一个多任务系统，任务T1负责从传感器读取数据，任务T2负责处理数据，任务T3负责将处理结果写入数据库。数据处理需要先完成数据读取，写入数据库需要数据处理完成。以下哪种PV操作序列能正确表示这种依赖关系？(假设sem1为T1完成后通知T2，sem2为T2完成后通知T3，初始值均为0) [2025, 模拟题]",
      "options": [
        "A. T1: V(sem1); T2: P(sem1), V(sem2); T3: P(sem2)",
        "B. T1: P(sem1); T2: V(sem1), P(sem2); T3: V(sem2)",
        "C. T1: V(sem2); T2: P(sem2), V(sem1); T3: P(sem1)",
        "D. T1: V(sem1); T2: V(sem2), P(sem1); T3: P(sem2)"
      ],
      "answer": "A",
      "analysis": "这种问题是经典的进程同步问题，通过信号量实现前趋关系。\n*   **T1 -> T2**：表示T1必须在T2之前完成。T1完成后应该发出一个信号，T2在开始前等待这个信号。我们用 `sem1` 来实现这个同步。T1执行 `V(sem1)`，T2执行 `P(sem1)`。`sem1` 初始值应为0，因为T2一开始不能执行，需要等待T1的信号。\n*   **T2 -> T3**：表示T2必须在T3之前完成。同理，T2完成后应该发出一个信号，T3在开始前等待这个信号。我们用 `sem2` 来实现这个同步。T2执行 `V(sem2)`，T3执行 `P(sem2)`。`sem2` 初始值也应为0。\n\n根据以上分析：\n*   T1负责执行并通知T2：`... (T1的工作) ... V(sem1);`\n*   T2等待T1通知，然后执行并通知T3：`P(sem1); ... (T2的工作) ... V(sem2);`\n*   T3等待T2通知，然后执行：`P(sem2); ... (T3的工作) ...`\n\n对比选项，A选项完全符合这个逻辑：\n`A. T1: V(sem1); T2: P(sem1), V(sem2); T3: P(sem2)`\n\n其他选项的P/V操作顺序或信号量使用不正确，会导致同步失败或死锁。"
    }
  ]
}